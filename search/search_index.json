{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"lvmh-ai-dataiku-plugin-retrieval-reco","text":"<p>This repository contains the deep2tower Dataiku plugin.</p>"},{"location":"#project-layout","title":"Project layout","text":"<ul> <li>  Plugin directory<ul> <li> <code>.github/</code> GitHub Actions and Workflows directory<ul> <li> <code>actions/</code> GitHub Actions directory<ul> <li> <code>action.yml</code> Setup Python and Poetry Action</li> </ul> <li> <code>workflows/</code> GitHub workflows directory<ul> <li> <code>github-actions.yml</code> GitHub Action CI</li> <li> <code>mkdocs-build.yml</code> Build and deploy MkDocs to GitHub Pages</li> <li> <code>semantic-release.yml</code> Run Semantic Release</li> </ul> <li> <code>code-env/</code> DSS env configuration directory<ul> <li> <code>spec/</code><ul> <li> <code>requirements.txt</code> DSS code env requirements</li> </ul> <li> <code>desc.json</code> Code env configuration</li> <li> <code>custom-recipes/</code> DSS custom recipes directory<ul> <li> <code>template-recipe</code> Custom recipe folder<ul> <li> <code>recipe.py</code> Recipe Python code</li> <li> <code>recipe.json</code> Recipe front and parameters</li> </ul> <li> <code>docs/</code> Documentation directory<ul> <li> <code>contributing</code> Base documentation folder<ul> <li> <code>documentation.md</code> Mkdocs usage to build documentation</li> <li> <code>github-ci-cd.md</code> GitHub CI usage</li> <li> <code>installation.md</code> Plugin installation fo dev</li> <li> <code>pre-commit.md</code> Pre-commit usage</li> <li> <code>tasks.md</code> Tasks usage</li> </ul> <li> <code>references</code> Libraries references documentation folder<ul> <li> <code>python-lib</code> Python-lib references folder<ul> <li> <code>your_module.md</code> To reference for auto-documentation</li> </ul> <li> <code>python-lib.md</code> Describe the main lib</li> <li> <code>coding-style.md</code> Code best practices</li> <li> <code>index.md</code> Home for documentation</li> <li> <code>python-lib/</code> Library directory<ul> <li> <code>src/</code> Source folder<ul> <li> <code>bin/</code> Main functions folder<ul> <li> Python files</li> <li> Other Python files</li> </ul> <li> <code>lib/</code> Classes and functions folder<ul> <li> Python files</li> <li> Other Python files</li> </ul> <li> <code>utils/</code> Utilities folder<ul> <li> Python files</li> <li> Other Python files</li> </ul> <li> <code>tests/</code> Test folder<ul> <li> Python files</li> </ul> <li> <code>tasks/</code> Task files directory<ul> <li> <code>taskfile.hook.yaml</code> Tasks file for running git hooks</li> <li> <code>taskfile.lock.yaml</code> Tasks file for running env export to dss env folder</li> <li> <code>taskfile.serve.yaml</code> Tasks file for running mkdocs local server</li> <li> Other tasks files</li> </ul> <li> <code>.gitignore</code> Git ignore file</li> <li> <code>.pre-commit-config.yaml</code> Pre commit hooks configuration file</li> <li> <code>mkdocs.yml</code> MkDocs configuration file</li> <li> <code>plugin.json</code> DSS plugin configuration file</li> <li> <code>poetry.toml</code> Poetry configuration file</li> <li> <code>pyproject.toml</code> Poetry project configuration file</li> <li> <code>README.md</code> README file</li> <li> <code>taskfile.yaml</code> Main tasks file </li>"},{"location":"coding-style/","title":"Coding style","text":"<p>This page lists the best practices for coding style. We strongly advise you to follow them.</p>"},{"location":"coding-style/#python-code","title":"Python code","text":"<ul> <li>Typing must be used in all classes and functions. Significant updates have been made to typing in the latest Python versions, but these versions are not yet supported on DSS, so please use the typing framework for complex types.</li> <li>Docstrings must follow the Google standard.</li> <li>Use a formatter and a linter, such as Ruff, to ensure your code is clean and readable.</li> <li>Always use absolute imports, and avoid importing any packages in __init__.py.</li> <li>Always use configuration files, like config.py, JSON configs, or environment variables.</li> <li>Use Poetry to manage dependencies and avoid conflicts you may encounter using pip.</li> <li>Write low-code versions of your code to create a recipe plugin, which can be done through additional classes or function wrappers.</li> <li>Use Jinja to create SQL templates that can be used within your Python methods.</li> </ul>"},{"location":"coding-style/#unit-tests","title":"Unit tests","text":"<ul> <li>Write simple unit tests with good coverage. Instead of testing every single function, focus on creating relevant tests for the main modules.</li> <li>Use the Pytest framework to write your tests, and take advantage of fixtures by using a conftest.py file at the root of your tests.</li> </ul>"},{"location":"coding-style/#logging","title":"Logging","text":"<ul> <li>While Dataiku captures print statements as logs (i.e., stdout), it is better to use logging. You can use the <code>LoggerManager</code> developed in the LVMH Core package.</li> </ul>"},{"location":"coding-style/#python-versioning","title":"Python versioning","text":"<p>Pyenv offers a straightforward method to manage Python versions, whether at the system or project level. It is highly recommended for ML Engineers to develop using Python versions compatible with maison's environments, particularly the available Dataiku Python versions. Currently, we recommend developing on Python 3.9.</p> <p>For other purposes, we suggest following a general rule of using an n-2 or n-1 major version from the most recent release. For instance, if Python 3.12 is the latest release, consider using 3.10 or 3.11. This approach helps mitigate dependency issues, as many Python packages may face compatibility challenges.</p> <p>To install Pyenv, please refer to the installation guidelines. For further information, you can also consult this article.</p>"},{"location":"contributing/documentation/","title":"Mkdocs usage to build documentation","text":"<p>The <code>mkdocs.yaml</code> file at the root of the repository is the configuration file for the MkDocs framework. The primary modification you may need to make is under the nav key, which is used to order pages and map them to the associated Markdown files.</p> <p>The <code>docs/</code> folder contains the documentation source files. Each Markdown file is linked to a page. Some of these pages are filled manually, while others are generated automatically using classes and functions' docstrings to build technical documentation.</p> <p>To generate technical documentation based on docstrings for a module, follow these steps:</p> <ol> <li>Create a Markdown File:</li> <li> <p>Create a new Markdown file inside the <code>references/</code> folder (you can organize it further by placing it inside a subfolder, e.g., <code>references/python-lib/</code>).</p> </li> <li> <p>Add a Title:</p> </li> <li> <p>Add a title to your Markdown file to clearly indicate its content.</p> </li> <li> <p>Include the Module Documentation:</p> </li> <li>Add the following line, replacing <code>&lt;path_from_root_to_your_file&gt;</code> with the path to the Python code you want to use as the documentation source:    <pre><code>::: &lt;path_from_root_to_your_file&gt;\n</code></pre></li> </ol> <p>That's it! Your technical documentation will now be generated based on the specified module's docstrings.</p> <p>To build and deploy the documentation, you can use a specific CI or run the following command:</p> <pre><code>poetry run mkdocs gh-deploy --force\n</code></pre> <p>This will create a branch named <code>gh-pages</code>, which you can then link to GitHub Pages.</p> <p>For more detailed information, refer to the official MkDocs documentation.</p>"},{"location":"contributing/github-ci-cd/","title":"GitHub Actions","text":"<p>GitHub Actions is a robust Continuous Integration/Continuous Development (CI/CD) tool provided by GitHub. It automates workflows by allowing you to build, test, and deploy your code directly from your GitHub repository. For more detailed information, see the official documentation.</p> <p>For plugin development, we utilize CI/CD to enforce code quality standards and streamline the release process. Our CI pipeline ensures that every merge request passes through a series of checks, including: - Linters and Formatters: We run Ruff for both linting and formatting to maintain a consistent and clean codebase. - Docstring Validation: We use Interrogate to verify that the code is properly documented with required docstrings. - Unit Tests: Comprehensive unit tests are executed to ensure no regressions or functional issues are introduced.</p> <p>In addition to these quality checks, we automate our release process using Semantic Release. This system manages versioning, updates tags, generates the CHANGELOG, and creates new releases based on commit messages, making the release process consistent and error-free.</p> <p>Our CI/CD also handles documentation using MkDocs. It automatically builds and deploys the latest documentation to a dedicated <code>gh-pages</code> branch, ensuring it is continuously updated and accessible via GitHub Pages.</p>"},{"location":"contributing/github-ci-cd/#setup-action","title":"Setup action","text":"<p>Purpose: This is a reusable GitHub Action for setting up Python and Poetry in your CI/CD workflows. It defines inputs, such as Python and Poetry versions, and steps to install and configure them.</p>"},{"location":"contributing/github-ci-cd/#key-sections","title":"Key Sections:","text":"<ul> <li>Inputs:</li> <li><code>python-version</code>: Specifies the Python version to use (default: <code>3.9</code>).</li> <li><code>poetry-version</code>: Specifies the Poetry version to use (default: <code>1.8.3</code>).</li> <li><code>poetry-args</code>: Allows additional arguments to be passed to Poetry.</li> <li> <p><code>load-cache</code>: Defines whether to load a cached virtual environment (default: <code>true</code>).</p> </li> <li> <p>Steps:</p> </li> <li>Set up Python: Installs and sets up the specified version of Python.</li> <li>Install Poetry: Installs the specified version of Poetry.</li> <li>Load cached venv: Attempts to load the cached virtual environment, speeding up dependency installation.</li> <li>Install dependencies: If the cache is not hit, it installs the dependencies using Poetry with any provided arguments.</li> </ul> <p>Usage: This action is reused in other workflows to set up the necessary environment for running Python and Poetry-based projects.</p>"},{"location":"contributing/github-ci-cd/#main-action","title":"Main action","text":"<p>Purpose: This workflow runs various quality checks and tests on every pull request to ensure code quality before merging. It includes steps to run linters, formatters, docstring validation, and unit tests.</p>"},{"location":"contributing/github-ci-cd/#key-sections_1","title":"Key Sections:","text":"<ul> <li>Triggers:</li> <li> <p>Runs on pull requests targeting the <code>main</code> or <code>dev</code> branches.</p> </li> <li> <p>Job Configuration:</p> </li> <li>Runs-on: Specifies the <code>ubuntu-latest</code> environment for running the CI pipeline.</li> <li> <p>Matrix: Defines a matrix strategy to test with different versions of Python (<code>3.9</code>) and Poetry (<code>1.8.3</code>).</p> </li> <li> <p>Steps:</p> </li> <li>Check-out repository: Fetches the code repository.</li> <li>Setup Workflow: Uses the custom <code>.github/actions/setup</code> action to set up Python and Poetry.</li> <li>Run Ruff linter: Runs Ruff to check code quality without modifying the code.</li> <li>Run Ruff formatter: Runs Ruff to check and enforce code formatting.</li> <li>Run Interrogate: Runs Interrogate to check for missing docstrings.</li> <li>Run unit tests: Runs unit tests using Pytest to ensure functionality.</li> </ul>"},{"location":"contributing/github-ci-cd/#mkdocs-build","title":"MkDocs build","text":"<p>Purpose: This workflow automatically builds and deploys MkDocs-based documentation to GitHub Pages when relevant changes are made to the documentation.</p>"},{"location":"contributing/github-ci-cd/#key-sections_2","title":"Key Sections:","text":"<ul> <li>Triggers:</li> <li> <p>Runs when the <code>Run Semantic Release</code> workflow completes successfully.</p> </li> <li> <p>Permissions:</p> </li> <li> <p>Grants write access to the contents to publish the built documentation.</p> </li> <li> <p>Job Configuration:</p> </li> <li>Runs-on: Specifies <code>ubuntu-latest</code>.</li> <li> <p>Matrix: Tests with Python <code>3.9</code> and Poetry <code>1.8.3</code>.</p> </li> <li> <p>Steps:</p> </li> <li>Check-out repository: Fetches the code repository.</li> <li>Setup Workflow: Uses the custom <code>.github/actions/setup</code> action to set up Python and Poetry.</li> <li>Configure Git credentials: Configures Git credentials using GitHub's default bot user for pushing changes to the repository.</li> <li>Build and deploy MkDocs: Builds the MkDocs documentation and deploys it to the <code>gh-pages</code> branch, making it available on GitHub Pages.</li> </ul>"},{"location":"contributing/github-ci-cd/#semantic-release","title":"Semantic Release","text":"<p>Purpose: This workflow automates versioning and the release process using Semantic Release. It manages tags, updates the CHANGELOG, and publishes new releases based on commit messages.</p>"},{"location":"contributing/github-ci-cd/#key-sections_3","title":"Key Sections:","text":"<ul> <li>Triggers:</li> <li> <p>Runs when a push is made to the <code>main</code> branch.</p> </li> <li> <p>Permissions:</p> </li> <li> <p>Grants write access to the contents and the GitHub ID token for managing the release.</p> </li> <li> <p>Job Configuration:</p> </li> <li>Runs-on: Specifies <code>ubuntu-latest</code>.</li> <li>Matrix: Tests with Python <code>3.9</code> and Poetry <code>1.8.3</code>.</li> <li> <p>Concurrency: Ensures that only one release job runs at a time.</p> </li> <li> <p>Steps:</p> </li> <li>Check-out repository: Fetches the entire code repository (all branches and tags).</li> <li>Setup Workflow: Uses the custom <code>.github/actions/setup</code> action to set up Python and Poetry.</li> <li>Run Semantic Release: Executes Semantic Release to manage versioning and generate a new release.</li> <li>Publish: Publishes package distributions to GitHub Releases.</li> </ul>"},{"location":"contributing/installation/","title":"Plugin installation","text":"<p>This guide provides step-by-step instructions for installing the plugin, including cloning the repository and initializing the project using Poetry for dependency management.</p>"},{"location":"contributing/installation/#cloning-the-repository","title":"Cloning the repository","text":"<p>To get started, you need to clone the repository to your local machine. Use the following command to clone the repository:</p> <pre><code>git clone &lt;repository_url&gt;\n</code></pre> <p>Replace <code>&lt;repository_url&gt;</code> with the actual URL of the repository.</p>"},{"location":"contributing/installation/#poetry-initialization","title":"Poetry initialization","text":"<p>Poetry is a tool for dependency management and packaging in Python. It helps manage dependencies and virtual environments efficiently. With Poetry, you can also define and configure tools like Ruff and Interrogate. Note that Poetry is configured through the <code>pyproject.toml</code> file to create in-project virtual environments.</p>"},{"location":"contributing/installation/#installing-poetry","title":"Installing Poetry","text":"<p>If you don't have Poetry installed, you can install it by following the instructions on the official Poetry installation page.</p>"},{"location":"contributing/installation/#basic-commands-for-poetry","title":"Basic commands for Poetry","text":"<ol> <li>Install dependencies:</li> </ol> <p>After cloning the repository, navigate to the project directory and run:</p> <pre><code>poetry install\n</code></pre> <p>This command will install all the dependencies listed in the <code>pyproject.toml</code> file and create a virtual environment based on the Poetry configuration in the <code>poetry.toml</code>.</p> <ol> <li>Activate the virtual environment:</li> </ol> <p>To activate the virtual environment created by Poetry, use:</p> <pre><code>poetry shell\n</code></pre> <p>This command will activate the virtual environment so you can work within it.</p> <ol> <li>Add a new dependency:</li> </ol> <p>If you need to add a new dependency to your project, run:</p> <pre><code>poetry add &lt;package_name&gt;\n</code></pre> <p>Replace <code>&lt;package_name&gt;</code> with the name of the package you want to add.</p> <ol> <li>Update dependencies:</li> </ol> <p>To update the dependencies to their latest versions, use:</p> <pre><code>poetry update\n</code></pre> <ol> <li>Run scripts or commands within the virtual environment:</li> </ol> <p>You can run any command within the virtual environment without activating it by prefixing it with <code>poetry run</code>. For example, to run tests using <code>pytest</code>, you can use:</p> <pre><code>poetry run pytest\n</code></pre> <p>By following these steps, you can effectively manage your project's dependencies and virtual environment using Poetry.</p>"},{"location":"contributing/pre-commit/","title":"Git hooks with Pre-commit","text":"<p>Pre-commit is a framework for managing and maintaining multi-language pre-commit hooks. It ensures that your code meets the required standards before committing. This framework provides several safeguards to enhance code quality and consistency, including:</p> <ul> <li>Preventing the commit of private keys: Ensures sensitive data like private keys are not accidentally committed.</li> <li>Preventing commits on the main branch: Enforces branching strategies to maintain a clean main branch.</li> <li>Preventing the commit of large files (more than 1000KB): Helps avoid adding excessively large files to the repository.</li> <li>Providing a code formatter and linter through Ruff: Ensures consistent code style and catches common errors.</li> <li>Providing a docstring coverage checker through Interrogate: Ensures that all functions and classes have appropriate documentation.</li> <li>Providing a dependencies export through Poetry: Manages and locks dependencies, ensuring consistent environments.</li> </ul> <p>Ruff is a fast code linting and formatting tool, written in Rust, designed to replace tools like Black, Flake8, and Isort. Interrogate checks for missing docstrings in the codebase, ensuring proper documentation coverage. Poetry is a dependency management tool that also manages virtual environments.</p>"},{"location":"contributing/pre-commit/#installation","title":"Installation","text":"<p>Pre-commit is normally installed automatically if you use the <code>task init</code> command. Otherwise, you can install it manually with the following command:</p> <pre><code>poetry run pre-commit install\n</code></pre> <p>Ensure you have run the <code>poetry install</code> command first to install all dependencies. In short, it is strongly recommended to use:</p> <pre><code>task init\n</code></pre> <p>If you are unsure how to use Task, refer to the Tasks page for guidance.</p>"},{"location":"contributing/pre-commit/#pre-commit-configuration","title":"Pre-commit configuration","text":"<p>Pre-commit is configured in the <code>.pre-commit-config.yaml</code> file, located at the root of the project. Some tools like Ruff and Interrogate are referenced in this file but are configured in the <code>pyproject.toml</code> file.</p> <p>The base configuration is as follows:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0\n    hooks:\n      - id: detect-private-key\n      - id: check-added-large-files\n        args: [--maxkb=1000]\n      - id: check-merge-conflict\n      - id: trailing-whitespace\n      - id: no-commit-to-branch\n        args: [--branch, main]\n\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.3.7\n    hooks:\n      - id: ruff\n        args: [--config, pyproject.toml]\n      - id: ruff-format\n        args: [--config, pyproject.toml]\n\n  - repo: https://github.com/python-poetry/poetry\n    rev: 1.4.0\n    hooks:\n      - id: poetry-lock\n      - id: poetry-export\n        args:\n          [\n            \"--without-hashes\",\n            \"-f\",\n            \"requirements.txt\",\n            \"-o\",\n            \"code-env/python/spec/requirements.txt\",\n          ]\n        verbose: true\n\n  - repo: https://github.com/econchick/interrogate\n    rev: 1.5.0\n    hooks:\n      - id: interrogate\n        args: [--config, pyproject.toml]\n</code></pre> <p>For more detailed information, visit the official Pre-commit documentation and see the list of available hooks.</p>"},{"location":"contributing/tasks/","title":"Shortcut using taskfile","text":"<p>Task is a task runner and build tool designed to be simpler and easier to use than tools like GNU Make. Written in Go, Task is a single binary with no other dependencies, making it straightforward to install and use without any complicated setup.</p> <p>To use Task, you simply describe your build tasks in a YAML schema within a file called <code>taskfile.yml</code>.</p>"},{"location":"contributing/tasks/#installation","title":"Installation","text":"<p>To install Task, follow the official installation guide.</p>"},{"location":"contributing/tasks/#running-tasks","title":"Running tasks","text":"<p>To run a task, use the following command in your terminal:</p> <pre><code>task &lt;task-name&gt;\n</code></pre> <p>For example, to initialize your project, run:</p> <pre><code>task init\n</code></pre>"},{"location":"contributing/tasks/#benefits-of-using-taskfile","title":"Benefits of using taskfile","text":"<ul> <li>Simplicity: Task provides a simple YAML-based configuration, making it easy to define and manage tasks.</li> <li>No Dependencies: Being a single binary with no dependencies, Task simplifies the setup process.</li> <li>Consistency: Using Task ensures that everyone on your team runs tasks in the same way, reducing the risk of errors and inconsistencies.</li> </ul>"},{"location":"references/python-lib/","title":"Python-lib references","text":"<p>Describe main lib used by the plugin.</p>"}]}